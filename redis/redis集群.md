### 主从库集群模式

redis的主从模式很简单，上一章redis主从复制详细介绍了主从工作的细节，可参考。

下面需要考虑redis主节点挂了怎么办，新的写操作还如何执行，从库也无法提供准确的数据支持。

#### 哨兵模式

redis采用哨兵模式解决主库宕机时的故障处理，哨兵就是redis的一个进程，它主要负责三个功能：

- 监控：监控主从库的运行状态，而且监控哨兵集群的其他哨兵的运行情况。

- 选主：主库宕机的时候，提升某个从库为主库

- 通知：让从库执行replicaof，连接新的主库同步，通知客户端连接新的主库

当检测到主库宕机时，哨兵如何选主并通知呢，我们一步步来解析：

1.首先，哨兵是如何监控主从库的运行状态的呢，哨兵进程会使用 PING 命令检测它自己和主、从库的网络连接情况，用来判断实例的状态。如果哨兵发现主库或从库对 PING 命令的响应超时了，那么，哨兵就会先把它标记为“主观下线”。还有种情况是客观下线，只有大部分的哨兵标记主库客观下线，才会认为主库宕机，进行主从切换。而客观下线存在的意义是为了避免因为网络原因，导致哨兵节点误判主库宕机。误判导致的主从切换成本很高。后续的选主和通知操作都会带来额外的计算和通信开销。这也是为什么存在哨兵集群的原因之一

![客观下线的判断](/Users/liuyangyang/刘阳阳/2021-interview/images/客观下线的判断.jpg)

2.当我们判断主库宕机后，就需要进行主从切换了。迎接而来的就是两个问题，
1.提升哪个从库为主呢？
2.哪个哨兵负责步骤一呢

问题一：提升哪个从库为主库呢，采用筛选+打分的方式，有以下两个一定

![redis新主库选择过程](/Users/liuyangyang/刘阳阳/2021-interview/images/redis新主库选择过程.jpg)1.网络情况进行筛选，除了要检查从库的当前在线状态，还要判断它之前的网络连接状态。如果从库总是和主库断连，而且断连次数超出了一定的阈值，我们就有理由相信，这个从库的网络状况并不是太好，就可以把这个从库筛掉了。

具体怎么判断呢？你使用配置项 down-after-milliseconds * 10。其中，down-after-milliseconds 是我们认定主从库断连的最大连接超时时间。如果在 down-after-milliseconds 毫秒内，主从节点都没有通过网络联系上，我们就可以认为主从节点断连了。如果发生断连的次数超过了 10 次，就说明这个从库的网络状况不好，不适合作为新主库。

2.打分：则分别是从库优先级、从库复制进度以及从库 ID 号依次判断，得分高的就升级为主库
从库优先级：可以手动设置，根据从库的配置情况，设定优先级
复制进：主要看各个从库的复制的进度slave_repl_offset，最大值就是复制进度最接近主库的
从库ID：生成从库的时候，默认会生成个从库ID，在优先级和复制进度都相同的情况下，ID 号最小的从库得分最高，会被选为新主库。

![redis-从库复制进度](/Users/liuyangyang/刘阳阳/2021-interview/images/redis-从库复制进度.jpg)

主观下线和客观下线
主观下线：哨兵集群中有哨兵发现主库下线后，也就是定时ping未回复后，会标记主库主观下线。
客观下线：因为主观下线可能可能是网络问题，导致回复慢，所以需要其他哨兵协助辅助。其他哨兵检测到主库标记为客观下线后，自己也会根据和自己的链接状态确认是否是主观下线。当集群中大部分的哨兵认为下线。则标记为客观下线，此时就会开始主从替换了。

如何进行切换呢？
选择领导哨兵执行切换。领导哨兵如何竞选呢？当主库客观下线后，哨兵会对其他哨兵发送请求，申请自己来执行主从替换。先给自己投一票，当其他哨兵接收到指令时，如果此时自己的票还未投出去，就同意。否则就拒绝。这里就存在个时间顺序的问题了。获得大多数票选的哨兵升级为领导哨兵，执行后续动作

通知从库。通知客户端
主从切换完成后，哨兵会给其他从库发送新的主库地址，让他们依附新主库更新，执行replicaof命令。而且也会通知客户端，此时主库的地址有更新，写操作需要发送到新的主库地址。客户端通知有2中方式，1.客户端订阅主从切换的消息，发生切换时，会受到通知。2.客户端需要自己获取主库地址。

哨兵提升一个从库为新主库后，哨兵会把新主库的地址写入自己实例的pubsub（switch-master）中。客户端需要订阅这个pubsub，当这个pubsub有数据时，客户端就能感知到主库发生变更，同时可以拿到最新的主库地址，然后把写请求写到这个新主库即可，这种机制属于哨兵主动通知客户端

问题：
1.主从切换的过程中，写命令会丢失嘛？

如果客户端使用了读写分离，那么读请求可以在从库上正常执行，不会受到影响。但是由于此时主库已经挂了，而且哨兵还没有选出新的主库，所以在这期间写请求会失败，失败持续的时间 = 哨兵切换主从的时间 + 客户端感知到新主库 的时间。

如果不想让业务感知到异常，客户端只能把写失败的请求先缓存起来或写入消息队列中间件中，等哨兵切换完主从后，再把这些写请求发给新的主库，但这种场景只适合对写入请求返回值不敏感的业务，而且还需要业务层做适配，另外主从切换时间过长，也会导致客户端或消息队列中间件缓存写请求过多，切换完成之后重放这些请求的时间变长。

2.1、哨兵集群中有实例挂了，怎么办，会影响主库状态判断和选主吗？

这个属于分布式系统领域的问题了，指的是在分布式系统中，如果存在故障节点，整个集群是否还可以提供服务？而且提供的服务是正确的？

这是一个分布式系统容错问题，这方面最著名的就是分布式领域中的“拜占庭将军”问题了，“拜占庭将军问题”不仅解决了容错问题，还可以解决错误节点的问题，虽然比较复杂，但还是值得研究的，有兴趣的同学可以去了解下。

简单说结论：存在故障节点时，只要集群中大多数节点状态正常，集群依旧可以对外提供服务。具体推导过程细节很多，大家去查前面的资料了解就好。

2、哨兵集群多数实例达成共识，判断出主库“客观下线”后，由哪个实例来执行主从切换呢？

哨兵集群判断出主库“客观下线”后，会选出一个“哨兵领导者”，之后整个过程由它来完成主从切换。

但是如何选出“哨兵领导者”？这个问题也是一个分布式系统中的问题，就是我们经常听说的共识算法，指的是集群中多个节点如何就一个问题达成共识。共识算法有很多种，例如Paxos、Raft，这里哨兵集群采用的类似于Raft的共识算法。

简单来说就是每个哨兵设置一个随机超时时间，超时后每个哨兵会请求其他哨兵为自己投票，其他哨兵节点对收到的第一个请求进行投票确认，一轮投票下来后，首先达到多数选票的哨兵节点成为“哨兵领导者”，如果没有达到多数选票的哨兵节点，那么会重新选举，直到能够成功选出“哨兵领导者”。

### Redis cluster模式

![redis-切片集群架构](/Users/liuyangyang/刘阳阳/2021-interview/images/redis-切片集群架构.jpg)

在应对数据量扩容时，虽然增加内存这种纵向扩展的方法简单直接，但是会造成数据库的内存过大，导致性能变慢。Redis 切片集群提供了横向扩展的模式，也就是使用多个实例，并给每个实例配置一定数量的哈希槽，数据可以通过键的哈希值映射到哈希槽，再通过哈希槽分散保存到不同的实例上。这样做的好处是扩展性好，不管有多少数据，切片集群都能应对。

![redis-切片集群槽分配](/Users/liuyangyang/刘阳阳/2021-interview/images/redis-切片集群槽分配.jpg)

另外，集群的实例增减，或者是为了实现负载均衡而进行的数据重新分布，会导致哈希槽和实例的映射关系发生变化，客户端发送请求时，会收到命令执行报错信息。了解了 MOVED 和 ASK 命令，你就不会为这类报错而头疼了。

![redis-客户端ask命令](/Users/liuyangyang/刘阳阳/2021-interview/images/redis-客户端ask命令.jpg)

![redis-客户端moved命令](/Users/liuyangyang/刘阳阳/2021-interview/images/redis-客户端moved命令.jpg)

和 MOVED 命令不同，ASK 命令并不会更新客户端缓存的哈希槽分配信息。所以，在上图中，如果客户端再次请求 Slot 2 中的数据，它还是会给实例 2 发送请求。这也就是说，ASK 命令的作用只是让客户端能给新实例发送一次请求，而不像 MOVED 命令那样，会更改本地缓存，让后续所有命令都发往新实例。